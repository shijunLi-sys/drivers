引用传递（Pass by Reference）是一种C++中的参数传递方式，它允许函数修改原始参数的值，
而不是只访问参数的副本。引用传递使用引用（reference）来传递参数，而不是使用参数的副本。
这使得函数能够直接访问和修改传递给它的参数，而不需要创建新的副本。

下面是一些关于引用传递的重要信息和示例：

引用的声明： 引用传递需要在函数的参数列表中使用引用符号&来声明参数是一个引用。
例如，int &x 声明了一个引用参数，可以用来传递一个整数的引用。

修改原始数据： 使用引用传递的函数可以直接修改原始参数的值，而不会创建参数的副本。
这意味着在函数内部对参数的任何更改都会反映在函数外部的原始数据上。

void modifyReference(int &x) {
    x = x + 10;
}

int main() {
    int num = 5;
    modifyReference(num);  // num的值现在为15，被修改了
    return 0;
}
避免副本开销： 与值传递不同，引用传递不会创建参数的副本，因此在传递大型数据结构时可以减少内存和性能开销。

传递常量引用： 你也可以使用常量引用（const reference）来传递参数，这表示函数不会修改参数的值。
常量引用通常用于提高性能和防止误操作。

void printValue(const int &x) {
    std::cout << x << std::endl;
}

int main() {
    int num = 5;
    printValue(num);  // 参数num的值可以被安全地传递给函数，因为它是常量引用
    return 0;
}
引用传递是C++中一种强大的参数传递方式，它允许函数更灵活地处理参数，
并且在需要修改参数值时提供了一种直接的方法。然而，需要小心使用引用传递，
以确保不会不小心修改原始数据，除非有意这样做


引用传递和指针传递都是在C++中用于传递参数给函数的方式，它们有一些重要的区别：

语法和符号：

引用传递使用引用符号&来声明参数，例如int &x表示一个引用参数。
指针传递使用指针变量来声明参数，例如int *ptr表示一个指针参数。
空值（Null Values）：

指针可以指向空值（nullptr），这意味着在指针传递中需要检查指针是否为null，以避免访问无效的内存。
引用不能引用空值，因此不需要担心引用传递中的空值问题。
初始化和重新赋值：

指针需要初始化，并且可以随后重新赋值，指向不同的内存地址。
引用在初始化时必须与某个变量绑定，且一旦绑定就不能再更改，它始终引用相同的变量。
语法和操作的差异：

使用指针传递参数时，需要使用*运算符来访问所指向的值，以及->运算符来访问通过指针访问成员。
使用引用传递参数时，直接使用变量名就可以访问和修改值，没有额外的运算符。
内存安全：

由于指针可以指向不同的内存位置，因此在使用指针传递参数时，需要更小心地处理内存安全问题，
以避免悬空指针和内存泄漏。引用传递通常更安全，因为它总是引用有效的内存位置，不会引发指针错误。
传递的目的：

指针通常用于传递可选参数或数组等数据结构，以便在函数内部进行遍历和修改。
引用通常用于传递普通的数据类型（如整数、浮点数、对象等），以便在函数内部修改原始值。
函数签名：

函数签名指的是函数的参数列表和返回类型。当使用引用传递时，函数签名与使用值传递的函数签名相同，
因此不会创建新的函数版本。而使用指针传递时，需要创建不同的函数版本，以便区分指针类型。
总之，引用传递和指针传递都有各自的优点和适用场景。引用传递通常更容易使用和更安全，
而指针传递提供了更多的灵活性，特别是在需要传递可选参数或进行复杂的数据结构操作时。
选择哪种方式取决于具体的需求和编程风格。